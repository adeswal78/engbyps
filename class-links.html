<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Video Links</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            background: linear-gradient(135deg, #f857a6 0%, #ff5858 100%);
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 900px;
            margin: 40px auto;
            padding: 24px;
            background: rgba(255, 255, 255, 0.97);
            border-radius: 18px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.13);
        }

        .back-btn {
            display: inline-block;
            margin-bottom: 18px;
            padding: 10px 22px;
            background: linear-gradient(90deg, #d7263d 0%, #fbb040 100%);
            color: #fff;
            border: none;
            border-radius: 10px;
            font-size: 1.08rem;
            cursor: pointer;
            font-weight: bold;
            text-decoration: none;
            box-shadow: 0 2px 8px #d7263d33;
            transition: background 0.2s, transform 0.15s;
        }

        .back-btn:hover {
            background: linear-gradient(90deg, #fbb040 0%, #d7263d 100%);
            transform: scale(1.07);
        }

        h1 {
            text-align: center;
            color: #d7263d;
            font-size: 2rem;
            letter-spacing: 2px;
            margin-bottom: 18px;
            font-family: 'Segoe UI Black', Arial, sans-serif;
            text-shadow: 2px 2px 0 #fff, 0 2px 8px #d7263d44;
        }

        .video-list {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .video-card {
            background: linear-gradient(135deg, #fffbe7 0%, #ffe0e6 100%);
            border-radius: 14px;
            box-shadow: 0 6px 24px #d7263d22;
            padding: 18px 20px;
            display: flex;
            flex-direction: column;
            border: 2px solid #fbb040;
            margin-bottom: 10px;
            transition: transform 0.22s, box-shadow 0.22s;
        }

        .video-card:hover {
            transform: scale(1.03) rotate(-1deg);
            box-shadow: 0 12px 36px #d7263d44;
            border-color: #d7263d;
        }

        .video-quality {
            font-size: 1.08rem;
            font-weight: 600;
            color: #d7263d;
            margin-bottom: 8px;
        }

        .video-link {
            color: #fbb040;
            text-decoration: underline;
            font-size: 1.05rem;
            word-break: break-all;
            margin-bottom: 4px;
            font-weight: 500;
            transition: color 0.2s;
        }

        .video-link:hover {
            color: #d7263d;
        }

        .no-videos {
            text-align: center;
            color: #fff;
            font-size: 1.1rem;
            margin-top: 40px;
            text-shadow: 1px 1px 0 #d7263d, 0 2px 8px #d7263d44;
        }

        @media (max-width: 700px) {
            .container {
                padding: 8px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <a id="backBtn" href="#" class="back-btn">&#8592; Back to Content</a>
        <h1>Video Links</h1>
        <div id="videoList" class="video-list"></div>
        <div id="noVideos" class="no-videos" style="display:none;">No video links found.</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script>
        // --- helpers ---
        function getQueryParam(name) {
            const url = new URL(window.location.href);
            return url.searchParams.get(name);
        }

        document.addEventListener('DOMContentLoaded', function () {
            const backBtn = document.getElementById('backBtn');
            backBtn.onclick = function (e) {
                e.preventDefault();
                window.history.back();
            };
        });

        // old AES-CBC decrypt (kept same)
        function decryptLink(enc) {
            if (!enc) return "";
            try {
                const b64 = String(enc).split(':')[0];
                const key = CryptoJS.enc.Utf8.parse('638udh3829162018');
                const iv = CryptoJS.enc.Utf8.parse('fedcba9876543210');
                const encrypted = CryptoJS.enc.Base64.parse(b64);
                const decrypted = CryptoJS.AES.decrypt({
                    ciphertext: encrypted
                }, key, {
                    iv: iv,
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
                });
                return decrypted.toString(CryptoJS.enc.Utf8);
            } catch (e) {
                return "";
            }
        }

        // check absolute url
        function isAbsoluteUrl(u) {
            try {
                const p = new URL(u);
                return p.protocol === 'http:' || p.protocol === 'https:';
            } catch (e) {
                return false;
            }
        }

        // try decrypt first; if decrypt returns usable url use it; otherwise if input itself is absolute, use it
        function resolveUrl(maybeEnc) {
            if (!maybeEnc) return "";
            // try decrypt
            const d = decryptLink(maybeEnc);
            if (d && isAbsoluteUrl(d)) return d;
            if (d) return d; // sometimes decrypted may be relative or okay
            // fallback: maybeEnc itself is plain url
            if (isAbsoluteUrl(maybeEnc)) return maybeEnc;
            // else try trimmed
            const t = String(maybeEnc).trim();
            if (isAbsoluteUrl(t)) return t;
            return "";
        }

        // Render list of link objects: {quality, path, backup_url, backup_url2}
        function renderVideos(videos) {
            const videoList = document.getElementById('videoList');
            videoList.innerHTML = '';
            videos.forEach(video => {
                const card = document.createElement('div');
                card.className = 'video-card';

                const quality = document.createElement('div');
                quality.className = 'video-quality';
                quality.textContent = video.quality || video.bitrate || "Unknown Quality";
                card.appendChild(quality);

                // Append only if resolved URL exists
                function appendLink(label, raw) {
                    const url = resolveUrl(raw);
                    if (!url) return;
                    const a = document.createElement('a');
                    a.href = url;
                    a.target = "_blank";
                    a.rel = "noopener noreferrer";
                    a.className = 'video-link';
                    a.textContent = label;
                    card.appendChild(a);
                }

                appendLink("Main Link", video.path || video.path_hls || video.path_main || video.url);
                appendLink("Backup Link 1", video.backup_url);
                appendLink("Backup Link 2", video.backup_url2);

                videoList.appendChild(card);
            });

            if (!videoList.hasChildNodes()) {
                document.getElementById('noVideos').style.display = 'block';
            } else {
                document.getElementById('noVideos').style.display = 'none';
            }
        }

        // Extract link objects from new API response (supports encrypted_links, download_links, livestream_links, file_link)
        function extractLinksFromApiData(dataObj) {
            const out = [];

            if (!dataObj) return out;

            // 1) encrypted_links (preferred in your sample)
            if (Array.isArray(dataObj.encrypted_links) && dataObj.encrypted_links.length > 0) {
                dataObj.encrypted_links.forEach(it => {
                    out.push({
                        quality: it.quality || it.bitrate || "Unknown",
                        path: it.path || "",
                        backup_url: it.backup_url || it.backup || it.backup_url || "",
                        backup_url2: it.backup_url2 || it.backup2 || "",
                    });
                });
                return out;
            }

            // 2) download_links (common)
            if (Array.isArray(dataObj.download_links) && dataObj.download_links.length > 0) {
                dataObj.download_links.forEach(it => {
                    out.push({
                        quality: it.quality || it.bitrate || it.bitrate || "Unknown",
                        path: it.path || "",
                        backup_url: it.backup_url || it.backup || "",
                        backup_url2: it.backup_url2 || "",
                    });
                });
                return out;
            }

            // 3) livestream_links
            if (Array.isArray(dataObj.livestream_links) && dataObj.livestream_links.length > 0) {
                dataObj.livestream_links.forEach(it => {
                    out.push({
                        quality: it.quality || it.bitrate || "Live",
                        path: it.path || it.url || "",
                        backup_url: it.backup_url || "",
                        backup_url2: it.backup_url2 || "",
                    });
                });
                return out;
            }

            // 4) single file_link / file_link fields (fallback)
            if (dataObj.file_link) {
                out.push({
                    quality: "Main",
                    path: dataObj.file_link,
                    backup_url: "",
                    backup_url2: ""
                });
                return out;
            }

            // 5) generic path / download_url / path fields if present
            if (dataObj.path || dataObj.video_player_url || dataObj.download_link) {
                out.push({
                    quality: dataObj.hls_stream_type ? `Type ${dataObj.hls_stream_type}` : "Main",
                    path: dataObj.path || dataObj.video_player_url || dataObj.download_link || "",
                    backup_url: "",
                    backup_url2: ""
                });
                return out;
            }

            return out;
        }

        // --- MAIN: fetch using new API endpoint fetchVideoDetailsById ---
        async function fetchVideoLinksUsingNewApi(videoId, folder_wise_course = 1, ytflag = 0) {
            try {
                // Accept multiple query param names for compatibility
                const courseId = getQueryParam("courseId") || getQueryParam("course_id") || getQueryParam("courseid") || "";
                const appId = getQueryParam("app_id") || ""; // keep if needed elsewhere

                if (!courseId || !videoId) {
                    document.getElementById('noVideos').textContent = "Missing courseId or videoId.";
                    document.getElementById('noVideos').style.display = 'block';
                    return;
                }

                // Build new API URL (as you provided)
                const base = "https://adeswal-eng.onrender.com/api/get/fetchVideoDetailsById";
                const url = `${base}?course_id=${encodeURIComponent(courseId)}&video_id=${encodeURIComponent(videoId)}&ytflag=${encodeURIComponent(ytflag)}&folder_wise_course=${encodeURIComponent(folder_wise_course)}&lc_app_api_url=`;
                console.log("Fetching new API:", url);

                const res = await fetch(url);
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const json = await res.json();
                console.log("New API response:", json);

                // API returns { status: 200, message:"...", data: { ... } }
                if (json.status === 200 && json.data) {
                    // extract links array
                    const links = extractLinksFromApiData(json.data);
                    // Render links (if links array non-empty)
                    if (links.length > 0) {
                        renderVideos(links);
                        return;
                    }

                    // If extract returned empty but there are other fallback fields, try to build
                    // For example some APIs may include download_links or file_link etc.
                    const fallback = extractLinksFromApiData(json.data);
                    if (fallback.length > 0) {
                        renderVideos(fallback);
                        return;
                    }

                    // If still no links
                    document.getElementById('noVideos').textContent = json.message || "No video links found.";
                    document.getElementById('noVideos').style.display = 'block';
                } else {
                    // Non-200 or missing data
                    document.getElementById('noVideos').textContent = json.message || "No video links found.";
                    document.getElementById('noVideos').style.display = 'block';
                }
            } catch (err) {
                console.error("Failed to load video links:", err);
                document.getElementById('noVideos').textContent = "Failed to load video links.";
                document.getElementById('noVideos').style.display = 'block';
            }
        }

        // Read both old & new param names for compatibility with your folder.html redirects
        const videoId = getQueryParam("videoId") || getQueryParam("videoid");
        const folder_wise_course = getQueryParam("folder_wise_course") || 1;
        const ytflag = getQueryParam("ytflag") || 0;

        if (videoId) {
            fetchVideoLinksUsingNewApi(videoId, folder_wise_course, ytflag);
        } else {
            document.getElementById('noVideos').textContent = "No video id provided.";
            document.getElementById('noVideos').style.display = 'block';
        }
    </script>
</body>

</html>
